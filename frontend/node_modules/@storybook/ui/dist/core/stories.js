"use strict";

require("core-js/modules/es6.object.define-property");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("core-js/modules/es6.string.iterator");

require("core-js/modules/es6.array.from");

require("core-js/modules/es6.regexp.to-string");

require("core-js/modules/es6.date.to-string");

require("core-js/modules/es7.symbol.async-iterator");

require("core-js/modules/es6.symbol");

require("core-js/modules/es6.array.find");

require("core-js/modules/es6.array.for-each");

require("core-js/modules/es6.object.assign");

require("core-js/modules/es6.function.name");

require("core-js/modules/es6.array.map");

require("core-js/modules/es7.object.values");

require("core-js/modules/es6.regexp.replace");

require("core-js/modules/es6.regexp.split");

require("core-js/modules/es7.array.includes");

require("core-js/modules/es6.string.includes");

require("core-js/modules/es6.array.find-index");

require("core-js/modules/es7.object.entries");

require("core-js/modules/es6.array.reduce");

require("core-js/modules/es6.array.index-of");

require("core-js/modules/es6.array.is-array");

require("core-js/modules/web.dom.iterable");

require("core-js/modules/es6.array.iterator");

require("core-js/modules/es6.object.to-string");

require("core-js/modules/es6.object.keys");

require("core-js/modules/es6.array.filter");

var _utils = require("@storybook/router/utils");

var _merge = _interopRequireDefault(require("../libs/merge"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

var initStoriesApi = function initStoriesApi(_ref) {
  var store = _ref.store,
      navigate = _ref.navigate,
      initialStoryId = _ref.storyId,
      initialViewMode = _ref.viewMode;

  var getData = function getData(storyId) {
    var _store$getState = store.getState(),
        storiesHash = _store$getState.storiesHash;

    return storiesHash[storyId];
  };

  var getCurrentStoryData = function getCurrentStoryData() {
    var _store$getState2 = store.getState(),
        storyId = _store$getState2.storyId;

    return getData(storyId);
  };

  var getParameters = function getParameters(storyId, addon) {
    var data = getData(storyId);

    if (!data) {
      return null;
    }

    var parameters = data.parameters;
    return addon ? parameters[addon] : parameters;
  };

  var jumpToStory = function jumpToStory(direction) {
    var _store$getState3 = store.getState(),
        storiesHash = _store$getState3.storiesHash,
        viewMode = _store$getState3.viewMode,
        storyId = _store$getState3.storyId; // cannot navigate when there's no current selection


    if (!storyId || !storiesHash[storyId]) {
      return;
    }

    var lookupList = Object.keys(storiesHash).filter(function (k) {
      return !(storiesHash[k].children || Array.isArray(storiesHash[k]));
    });
    var index = lookupList.indexOf(storyId); // cannot navigate beyond fist or last

    if (index === lookupList.length - 1 && direction > 0) {
      return;
    }

    if (index === 0 && direction < 0) {
      return;
    }

    if (direction === 0) {
      return;
    }

    var result = lookupList[index + direction];

    if (viewMode && result) {
      navigate("/".concat(viewMode, "/").concat(result));
    }
  };

  var jumpToComponent = function jumpToComponent(direction) {
    var state = store.getState();
    var storiesHash = state.storiesHash,
        viewMode = state.viewMode,
        storyId = state.storyId; // cannot navigate when there's no current selection

    if (!storyId || !storiesHash[storyId]) {
      return;
    }

    var lookupList = Object.entries(storiesHash).reduce(function (acc, i) {
      var value = i[1];

      if (value.isComponent) {
        acc.push(_toConsumableArray(i[1].children));
      }

      return acc;
    }, []);
    var index = lookupList.findIndex(function (i) {
      return i.includes(storyId);
    }); // cannot navigate beyond fist or last

    if (index === lookupList.length - 1 && direction > 0) {
      return;
    }

    if (index === 0 && direction < 0) {
      return;
    }

    if (direction === 0) {
      return;
    }

    var result = lookupList[index + direction][0];
    navigate("/".concat(viewMode || 'story', "/").concat(result));
  };

  var splitPath = function splitPath(kind, _ref2) {
    var rootSeparator = _ref2.rootSeparator,
        groupSeparator = _ref2.groupSeparator;

    var _kind$split = kind.split(rootSeparator, 2),
        _kind$split2 = _slicedToArray(_kind$split, 2),
        root = _kind$split2[0],
        remainder = _kind$split2[1];

    var groups = (remainder || kind).split(groupSeparator).filter(function (i) {
      return !!i;
    }); // when there's no remainder, it means the root wasn't found/split

    return {
      root: remainder ? root : null,
      groups: groups
    };
  };

  var toKey = function toKey(input) {
    return input.replace(/[^a-z0-9]+([a-z0-9])/gi, function () {
      for (var _len = arguments.length, params = new Array(_len), _key = 0; _key < _len; _key++) {
        params[_key] = arguments[_key];
      }

      return params[1].toUpperCase();
    });
  };

  var toGroup = function toGroup(name) {
    return {
      name: name,
      children: [],
      id: toKey(name)
    };
  };

  var setStories = function setStories(input) {
    // This doesn't quite have the right order -- it does not group the top-level keys, see #5518
    var storiesHashOutOfOrder = Object.values(input).reduce(function (acc, item) {
      var kind = item.kind,
          parameters = item.parameters;
      var _parameters$options = parameters.options,
          rootSeparator = _parameters$options.hierarchyRootSeparator,
          groupSeparator = _parameters$options.hierarchySeparator;

      var _splitPath = splitPath(kind, {
        rootSeparator: rootSeparator,
        groupSeparator: groupSeparator
      }),
          root = _splitPath.root,
          groups = _splitPath.groups;

      var rootAndGroups = [].concat(root || []).concat(groups).map(toGroup) // Map a bunch of extra fields onto the groups, collecting the path as we go (thus the reduce)
      .reduce(function (soFar, group, index, original) {
        var name = group.name;
        var parent = index > 0 && soFar[index - 1].id;
        var id = (0, _utils.sanitize)(parent ? "".concat(parent, "-").concat(name) : name);
        return soFar.concat([Object.assign({}, group, {
          id: id,
          parent: parent,
          depth: index,
          isComponent: index === original.length - 1,
          isLeaf: false,
          isRoot: !!root && index === 0
        })]);
      }, []);
      var paths = [].concat(_toConsumableArray(rootAndGroups.map(function (g) {
        return g.id;
      })), [item.id]); // Ok, now let's add everything to the store

      rootAndGroups.forEach(function (group, index) {
        var child = paths[index + 1];
        var id = group.id;
        acc[id] = (0, _merge.default)(acc[id] || {}, Object.assign({}, group, child && {
          children: [child]
        }));
      });
      acc[item.id] = Object.assign({}, item, {
        parent: rootAndGroups[rootAndGroups.length - 1].id,
        isLeaf: true
      });
      return acc;
    }, {}); // When adding a group, also add all of its children, depth first

    function addItem(acc, item) {
      if (!acc[item]) {
        // If we were already inserted as part of a group, that's great.
        acc[item.id] = item;
        var children = item.children;

        if (children) {
          children.forEach(function (id) {
            return addItem(acc, storiesHashOutOfOrder[id]);
          });
        }
      }

      return acc;
    } // Now create storiesHash by reordering the above by group


    var storiesHash = Object.values(storiesHashOutOfOrder).reduce(addItem, {});

    var _store$getState4 = store.getState(),
        storyId = _store$getState4.storyId,
        viewMode = _store$getState4.viewMode;

    if (!storyId || !storiesHash[storyId]) {
      // when there's no storyId or the storyId item doesn't exist
      // we pick the first leaf and navigate
      var firstLeaf = Object.values(storiesHash).find(function (s) {
        return !s.children;
      });

      if (viewMode && firstLeaf) {
        navigate("/".concat(viewMode, "/").concat(firstLeaf.id));
      }
    }

    store.setState({
      storiesHash: storiesHash
    });
  };

  var selectStory = function selectStory(kindOrId, story) {
    var _store$getState5 = store.getState(),
        _store$getState5$view = _store$getState5.viewMode,
        viewMode = _store$getState5$view === void 0 ? 'story' : _store$getState5$view,
        storyId = _store$getState5.storyId,
        storiesHash = _store$getState5.storiesHash;

    if (!story) {
      var s = storiesHash[(0, _utils.sanitize)(kindOrId)]; // eslint-disable-next-line no-nested-ternary

      var id = s ? s.children ? s.children[0] : s.id : kindOrId;
      navigate("/".concat(viewMode, "/").concat(id));
    } else if (!kindOrId) {
      // This is a slugified version of the kind, but that's OK, our toId function is idempotent
      var kind = storyId.split('--', 2)[0];
      selectStory((0, _utils.toId)(kind, story));
    } else {
      selectStory((0, _utils.toId)(kindOrId, story));
    }
  };

  return {
    api: {
      storyId: _utils.toId,
      selectStory: selectStory,
      getCurrentStoryData: getCurrentStoryData,
      setStories: setStories,
      jumpToComponent: jumpToComponent,
      jumpToStory: jumpToStory,
      getData: getData,
      getParameters: getParameters
    },
    state: {
      storiesHash: {},
      storyId: initialStoryId,
      viewMode: initialViewMode
    }
  };
};

var _default = initStoriesApi;
exports.default = _default;