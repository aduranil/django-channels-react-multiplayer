"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.STORAGE_KEY = void 0;

require("core-js/modules/es6.object.define-property");

require("core-js/modules/es6.promise");

require("core-js/modules/es6.object.to-string");

require("regenerator-runtime/runtime");

require("core-js/modules/es6.object.assign");

var _global = require("global");

var _telejson = require("telejson");

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var STORAGE_KEY = '@storybook/ui/store';
exports.STORAGE_KEY = STORAGE_KEY;

function get(storage) {
  var serialized = storage.getItem(STORAGE_KEY);
  return serialized ? (0, _telejson.parse)(serialized) : {};
}

function set(storage, value) {
  storage.setItem(STORAGE_KEY, (0, _telejson.stringify)(value, {
    maxDepth: 50
  }));
}

function update(storage, patch) {
  var previous = get(storage); // Apply the same behaviour as react here

  set(storage, Object.assign({}, previous, patch));
} // Our store piggybacks off the internal React state of the Context Provider
// It has been augmented to persist state to local/sessionStorage


var Store =
/*#__PURE__*/
function () {
  function Store(_ref) {
    var setState = _ref.setState,
        getState = _ref.getState;

    _classCallCheck(this, Store);

    this.upstreamSetState = setState;
    this.upstreamGetState = getState;
  } // The assumption is that this will be called once, to initialize the React state
  // when the module is instanciated


  _createClass(Store, [{
    key: "getInitialState",
    value: function getInitialState() {
      // We don't only merge at the very top level (the same way as React setState)
      // when you set keys, so it makes sense to do the same in combining the two storage modes
      // Really, you shouldn't store the same key in both places
      return Object.assign({}, get(_global.localStorage), get(_global.sessionStorage));
    }
  }, {
    key: "getState",
    value: function getState() {
      return this.upstreamGetState();
    }
  }, {
    key: "setState",
    value: function () {
      var _setState = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee(inputPatch, cbOrOptions, inputOptions) {
        var _this = this;

        var callback, options, _ref2, _ref2$persistence, persistence, patch, delta, newState, storage;

        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (typeof cbOrOptions === 'function') {
                  callback = cbOrOptions;
                  options = inputOptions;
                } else {
                  options = cbOrOptions;
                }

                _ref2 = options || {}, _ref2$persistence = _ref2.persistence, persistence = _ref2$persistence === void 0 ? 'none' : _ref2$persistence;

                if (typeof inputPatch === 'function') {
                  // Pass the same function, but just set delta on the way
                  patch = function patch(state) {
                    delta = inputPatch(state);
                    return delta;
                  };
                } else {
                  patch = inputPatch;
                  delta = patch;
                }

                _context.next = 5;
                return new Promise(function (resolve) {
                  _this.upstreamSetState(patch, resolve);
                });

              case 5:
                newState = _context.sent;

                if (!(persistence !== 'none')) {
                  _context.next = 10;
                  break;
                }

                storage = persistence === 'session' ? _global.sessionStorage : _global.localStorage;
                _context.next = 10;
                return update(storage, delta);

              case 10:
                if (callback) {
                  callback(newState);
                }

                return _context.abrupt("return", newState);

              case 12:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      function setState(_x, _x2, _x3) {
        return _setState.apply(this, arguments);
      }

      return setState;
    }()
  }]);

  return Store;
}();

exports.default = Store;